# app.py
import json
from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import JSONResponse, FileResponse, HTMLResponse
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel
from typing import List, Optional
from datetime import datetime, timedelta
import pandas as pd
import numpy as np
from prophet import Prophet
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LogisticRegression
import os

app = FastAPI()

# Static files serving setup - React build files will be placed here
if not os.path.exists("frontend/dist"):
    os.makedirs("frontend/dist")

app.mount("/static", StaticFiles(directory="frontend/dist/static"), name="static")

# Simple in-memory data storage
USERS = {"user1": {"goals": [], "budgets": {}, "transactions": []}}

CATEGORIES = ["Food", "Transport", "Entertainment", "Utilities", "Others"]

# Expense Categorization ML Model (simple logistic regression)
vectorizer = TfidfVectorizer()
clf = LogisticRegression()

train_texts = [
    "grocery supermarket",
    "bus ticket",
    "movie cinema",
    "electricity bill",
    "dinner restaurant",
    "taxi ride",
    "concert",
    "water bill",
    "snack",
    "uber",
]
train_labels = [
    "Food",
    "Transport",
    "Entertainment",
    "Utilities",
    "Food",
    "Transport",
    "Entertainment",
    "Utilities",
    "Food",
    "Transport",
]
X_train = vectorizer.fit_transform(train_texts)
clf.fit(X_train, train_labels)

# Models
class Transaction(BaseModel):
    date: datetime
    amount: float
    description: str
    category: Optional[str] = None

class Goal(BaseModel):
    name: str
    target_amount: float
    deadline: datetime

class Budget(BaseModel):
    category: str
    limit: float

class TransactionsUpload(BaseModel):
    username: str
    transactions: List[Transaction]

class GoalsUpdate(BaseModel):
    username: str
    goal: Goal

class BudgetUpdate(BaseModel):
    username: str
    budget: Budget

@app.post("/api/upload_transactions")
def upload_transactions(data: TransactionsUpload):
    user = USERS.get(data.username)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    new_transactions = []
    for tx in data.transactions:
        if not tx.category:
            cat = predict_category(tx.description)
        else:
            cat = tx.category
        transaction = {
            "date": tx.date,
            "amount": tx.amount,
            "description": tx.description,
            "category": cat,
        }
        new_transactions.append(transaction)
    user["transactions"].extend(new_transactions)
    return {"status": "success", "added": len(new_transactions)}

def predict_category(text):
    x = vectorizer.transform([text])
    pred = clf.predict(x)[0]
    return pred

@app.get("/api/transactions/{username}")
def get_transactions(username: str):
    user = USERS.get(username)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return user["transactions"]

@app.post("/api/add_goal")
def add_goal(data: GoalsUpdate):
    user = USERS.get(data.username)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    user["goals"].append(data.goal.dict())
    return {"status": "goal added"}

@app.get("/api/goals/{username}")
def get_goals(username: str):
    user = USERS.get(username)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return user["goals"]

@app.post("/api/set_budget")
def set_budget(data: BudgetUpdate):
    user = USERS.get(data.username)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    user["budgets"][data.budget.category] = data.budget.limit
    return {"status": "budget set"}

@app.get("/api/budgets/{username}")
def get_budgets(username: str):
    user = USERS.get(username)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return user["budgets"]

@app.get("/api/predict_spending/{username}")
def predict_spending(username: str):
    user = USERS.get(username)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    df = pd.DataFrame(user["transactions"])
    if df.empty:
        return {"forecast": []}

    df['date'] = pd.to_datetime(df['date'])
    df = df.groupby('date').agg({'amount': 'sum'}).reset_index()
    df = df.rename(columns={"date": "ds", "amount": "y"})

    model = Prophet(daily_seasonality=True)
    model.fit(df)

    future = model.make_future_dataframe(periods=30)
    forecast = model.predict(future)

    result = forecast[['ds', 'yhat']].tail(30).to_dict(orient='records')

    return {"forecast": result}

@app.get("/api/budget_alerts/{username}")
def budget_alerts(username: str):
    user = USERS.get(username)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    alerts = []
    budgets = user["budgets"]
    txs = user["transactions"]
    if not budgets or not txs:
        return alerts

    df = pd.DataFrame(txs)
    df['date'] = pd.to_datetime(df['date'])
    month_start = datetime.now().replace(day=1)
    df = df[df['date'] >= month_start]

    for cat, limit in budgets.items():
        spent = df[df['category'] == cat]['amount'].sum()
        if spent > limit:
            alerts.append(f"Budget exceeded for {cat}: Spent {spent:.2f}, Limit {limit:.2f}")
        elif spent > 0.8 * limit:
            alerts.append(f"Warning: Spending approaching limit for {cat}: Spent {spent:.2f}, Limit {limit:.2f}")
    return alerts

# Dummy data for demo
USERS["user1"]["transactions"] = [
    {"date": (datetime.now() - timedelta(days=i)).isoformat(), "amount": 20 + i, "description": "grocery supermarket", "category": "Food"}
    for i in range(10)
]

USERS["user1"]["budgets"] = {"Food": 250, "Transport": 100}

# Serve React frontend
@app.get("/")
async def serve_react():
    html_path = "frontend/dist/index.html"
    if os.path.exists(html_path):
        with open(html_path, 'r') as f:
            html_content = f.read()
        return HTMLResponse(content=html_content, status_code=200)
    else:
        # Return minimal React page if no build found
        return HTMLResponse(content=minimal_react_html(), status_code=200)

def minimal_react_html():
    # A minimal React app bundled inside HTML
    return """
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>AI Financial Tool</title>
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script crossorigin src="https://unpkg.com/axios/dist/axios.min.js"></script>
<style>
  body { font-family: Arial, sans-serif; padding: 20px; }
  input, button { margin: 5px 0; padding: 8px; font-size: 14px; }
  table { border-collapse: collapse; width: 100%; margin-top: 10px;}
  th, td { border: 1px solid #ccc; padding: 8px; }
</style>
</head>
<body>
<div id="root"></div>
<script type="text/javascript">
const e = React.createElement;

function App() {
  const [transactions, setTransactions] = React.useState([]);
  const [forecast, setForecast] = React.useState([]);
  const [alerts, setAlerts] = React.useState([]);
  const [goals, setGoals] = React.useState([]);
  const [budgets, setBudgets] = React.useState({});
  const [formTx, setFormTx] = React.useState({ description: "", amount: "", date: "" });
  const [goalForm, setGoalForm] = React.useState({ name: "", target_amount: "", deadline: "" });
  const [budgetForm, setBudgetForm] = React.useState({ category: "", limit: "" });

  const username = "user1";
  const apiBase = "/api";

  React.useEffect(() => {
    fetchTransactions();
    fetchForecast();
    fetchAlerts();
    fetchGoals();
    fetchBudgets();
  }, []);

  function fetchTransactions() {
    axios.get(apiBase + "/transactions/" + username)
      .then(res => setTransactions(res.data))
      .catch(console.error);
  }
  function fetchForecast() {
    axios.get(apiBase + "/predict_spending/" + username)
      .then(res => setForecast(res.data.forecast))
      .catch(console.error);
  }
  function fetchAlerts() {
    axios.get(apiBase + "/budget_alerts/" + username)
      .then(res => setAlerts(res.data))
      .catch(console.error);
  }
  function fetchGoals() {
    axios.get(apiBase + "/goals/" + username)
      .then(res => setGoals(res.data))
      .catch(console.error);
  }
  function fetchBudgets() {
    axios.get(apiBase + "/budgets/" + username)
      .then(res => setBudgets(res.data))
      .catch(console.error);
  }

  function addTransaction() {
    if (!formTx.date || !formTx.description || !formTx.amount) {
      alert("Fill all transaction fields");
      return;
    }
    const tx = {
      date: formTx.date,
      amount: parseFloat(formTx.amount),
      description: formTx.description,
    };
    axios.post(apiBase + "/upload_transactions", { username, transactions: [tx] })
      .then(() => {
        fetchTransactions();
        fetchAlerts();
        fetchForecast();
        setFormTx({ description: "", amount: "", date: "" });
      }).catch(console.error);
  }

  function addGoal() {
    if (!goalForm.name || !goalForm.target_amount || !goalForm.deadline) {
      alert("Fill all goal fields");
      return;
    }
    const goal = {
      name: goalForm.name,
      target_amount: parseFloat(goalForm.target_amount),
      deadline: goalForm.deadline,
    };
    axios.post(apiBase + "/add_goal", { username, goal })
      .then(() => {
        fetchGoals();
        setGoalForm({ name: "", target_amount: "", deadline: "" });
      }).catch(console.error);
  }

  function setBudget() {
    if (!budgetForm.category || !budgetForm.limit) {
      alert("Fill all budget fields");
      return;
    }
    const budget = {
      category: budgetForm.category,
      limit: parseFloat(budgetForm.limit),
    };
    axios.post(apiBase + "/set_budget", { username, budget })
      .then(() => {
        fetchBudgets();
        fetchAlerts();
        setBudgetForm({ category: "", limit: "" });
      }).catch(console.error);
  }

  return e("div", null,
    e("h1", null, "AI Financial Tool Dashboard"),
    e("section", null,
      e("h2", null, "Add Transaction"),
      e("input", {
        type: "date",
        value: formTx.date,
        onChange: e => setFormTx({ ...formTx, date: e.target.value }),
      }),
      e("input", {
        type: "text",
        placeholder: "Description",
        value: formTx.description,
        onChange: e => setFormTx({ ...formTx, description: e.target.value }),
      }),
      e("input", {
        type: "number",
        placeholder: "Amount",
        value: formTx.amount,
        onChange: e => setFormTx({ ...formTx, amount: e.target.value }),
      }),
      e("button", { onClick: addTransaction }, "Add")
    ),
    e("section", null,
      e("h2", null, "Transactions"),
      e("table", null,
        e("thead", null,
          e("tr", null,
            e("th", null, "Date"),
            e("th", null, "Description"),
            e("th", null, "Category"),
            e("th", null, "Amount")
          )
        ),
        e("tbody", null,
          transactions.map((tx, idx) =>
            e("tr", { key: idx },
              e("td", null, new Date(tx.date).toLocaleDateString()),
              e("td", null, tx.description),
              e("td", null, tx.category),
              e("td", null, `$${tx.amount.toFixed(2)}`)
            )
          )
        )
      )
    ),
    e("section", null,
      e("h2", null, "Spending Forecast (Next 30 days)"),
      e("ul", null,
        forecast.map((f, idx) =>
          e("li", { key: idx }, `${new Date(f.ds).toLocaleDateString()}: $${f.yhat.toFixed(2)}`)
        )
      )
    ),
    e("section", null,
      e("h2", null, "Budget Alerts"),
      alerts.length === 0 ? e("p", null, "No alerts") : alerts.map((a, i) => e("p", { key: i }, a))
    ),
    e("section", null,
      e("h2", null, "Set Budget"),
      e("input", {
        type: "text",
        placeholder: "Category",
        value: budgetForm.category,
        onChange: e => setBudgetForm({ ...budgetForm, category: e.target.value }),
      }),
      e("input", {
        type: "number",
        placeholder: "Limit",
        value: budgetForm.limit,
        onChange: e => setBudgetForm({ ...budgetForm, limit: e.target.value }),
      }),
      e("button", { onClick: setBudget }, "Set"),
      e("h3", null, "Current Budgets:"),
      e("ul", null,
        Object.entries(budgets).map(([cat, limit], idx) =>
          e("li", { key: idx }, `${cat}: $${limit.toFixed(2)}`)
        )
      )
    ),
    e("section", null,
      e("h2", null, "Add Goal"),
      e("input", {
        type: "text",
        placeholder: "Goal Name",
        value: goalForm.name,
        onChange: e => setGoalForm({ ...goalForm, name: e.target.value }),
      }),
      e("input", {
        type: "number",
        placeholder: "Target Amount",
        value: goalForm.target_amount,
        onChange: e => setGoalForm({ ...goalForm, target_amount: e.target.value }),
      }),
      e("input", {
        type: "date",
        placeholder: "Deadline",
        value: goalForm.deadline,
        onChange: e => setGoalForm({ ...goalForm, deadline: e.target.value }),
      }),
      e("button", { onClick: addGoal }, "Add Goal"),
      e("h3", null, "Goals:"),
      e("ul", null,
        goals.map((g, idx) =>
          e("li", { key: idx }, `${g.name}: $${g.target_amount} by ${new Date(g.deadline).toLocaleDateString()}`)
        )
      )
    )
  );
}

const domContainer = document.querySelector('#root');
ReactDOM.createRoot(domContainer).render(e(App));
</script>
</body>
</html>
"""

